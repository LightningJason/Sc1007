1. createQueueFromLinkedList(1) a2q1
2. createStackFromLinkedList(1) a2q2
3. isStackPairwiseConsecutive(1) a2q3
4. reverseQueue(1) a2q4
5. removeUntil(1) l2q1
6. recursiveReverse(1) l2q2
7. palindrom(1) l2q3
E8. balanced(1) l2q4
--------------------------------------------------------------------------------------------------
1. createQueueFromLinkedList()
int x=ll->size, i;
	ListNode *temp;

	//empty queue
	while(!isEmptyQueue(q)){
        dequeue(q);
	}
	//sanity check
    if (x==0) return;
	//add
	temp=ll->head;
	for (i=0;i<x;i++){
	enqueue(q,temp->item);
	temp=temp->next;
	}
	return;
--------------------------------------------------------------------------------------------------
2. createStackFromLinkedList()
int x=ll->size,i;
	ListNode *temp;
	//empty list
	while(!isEmptyStack(s)) pop(s);

	//sanity check
	if (x==0) return;
	temp=ll->head;
	for(i=0;i<x;i++){
        push(s,temp->item);
        temp=temp->next;
	}
	return;
--------------------------------------------------------------------------------------------------
3. isStackPairwiseConsecutive()
int x=s->ll.size,i,a,b;
  if (x==0) return 0;
  if (x%2==1) return 0;
  for (i=0;i<x/2;i++){
        a=pop(s);
        b=pop(s);
        if (a==b+1||a==b-1) continue;
        else return 0;
  }
  return 1;
}
void push(Stack *s, int item){
   insertNode(&(s->ll), 0, item);
}

int pop(Stack *s){
   int item;
   if(!isEmptyStack(s)){
    item = ((s->ll).head)->item;
    removeNode(&(s->ll), 0);
    return item;
   }
    return INT_MIN;
--------------------------------------------------------------------------------------------------
4. reverseQueue()
    Stack s;
    s.ll.head=NULL;
    s.ll.size=0;

    while(!isEmptyQueue(q))push(&s,dequeue(q));
    while(!isEmptyStack(&s)) enqueue(q,pop(&s));
    return;
--------------------------------------------------------------------------------------------------
5. removeUntil()
while (!isEmptyStack(s)){
        if (peek(s)!=value) {
            pop(s);
        }
        else break;

}
--------------------------------------------------------------------------------------------------
6. recursiveReverse()
if (isEmptyQueue(q)) return;
	int i=dequeue(q);
	recursiveReverse(q);
	enqueue(q,i);
	return;
	/*Stack s;
	s.ll.head=NULL;
	s.ll.size=0;
	while (!isEmptyQueue(q)){
        push(&s,dequeue(q));
	}
	while (!isEmptyStack(&s)){
        enqueue(q,pop(&s));
	}*/
--------------------------------------------------------------------------------------------------
7. palindrom()
printf("%s\n", word);
	Stack s;
	s.ll.head=NULL;
	s.ll.size=0;
	Queue q;
	q.ll.head=NULL;
	q.ll.size=0;

	while (*word){
        if (*word!=' '){
        push(&s,toupper(*word));
        enqueue(&q,toupper(*word));
        }
        word++;
	}
  //for (i=0;i<5;i++){
	while (!isEmptyQueue(&q)){
        if (dequeue(&q)!=pop(&s)){
            printf("The string is not a palindrome.\n");
            return -1;
        }
	}
	printf("The String is a palindrome.\n");
	return 0;
// Put the whole string in a stack, stripping out spaces
/*
     int i;
     Stack s; Queue q;
     s.ll.head = NULL;
     s.ll.tail = NULL;
     s.ll.size = 0;
     q.ll.head = NULL;
     q.ll.tail = NULL;
     q.ll.size = 0;

     // Put the whole string in a stack and a queue, stripping out spaces
     printf("%s\n", word);
     while (*word){
          if (*word != ' '){
               push(&s, toupper(*word));
               enqueue(&q, toupper(*word));
          }
          word++;
     }
     // divide size by 2,ignore the middle character in an odd-length string
     i = s.ll.size / 2; //i = 2 (5/2=2)

     // Pop first half of stripped string off the stack
     //Compare with the second half
     while (i > 0){
          if (pop(&s) != dequeue(&q)){
               printf("The string is not a palindrome\n");
               return -1;
          }
          i--;
     }
     printf("The string is a palindrome\n");
     return 0;*/
--------------------------------------------------------------------------------------------------
E8. balanced()
Stack s;
	s.ll.head=NULL;
	s.ll.size=0;

    while (*expression){
        if (*expression=='{'||*expression=='['||*expression=='('){
                push(&s,*expression);

        }
        else if(*expression=='}'){
            if (isEmptyStack(&s)||pop(&s)!='{') return -1;
        }
        else if(*expression==']'){
            if (isEmptyStack(&s)||pop(&s)!='[') return -1;
        }
        else if(*expression==')'){
            if (isEmptyStack(&s)||pop(&s)!='(') return -1;
        }
        expression++;
    }
    if(isEmptyStack(&s)) return 0;
    else return -1;
	/*
	int a1=0,a2=0,b1=0,b2=0,c1=0,c2=0;
	while(*expression){
        if (*expression=='(') {a1+=1;}
        if (*expression==')') a2+=1;
        if (*expression=='[') b1+=1;
        if (*expression==']') b2+=1;
        if (*expression=='{') c1+=1;
        if (*expression=='}') c2+=1;
        expression++;
	}
    if (a1!=a2 || b1!=b2 || c1!=c2){
        return 1;
    }
    return 0;*/
