1. createQueueFromLinkedList(1) a2q1
2. createStackFromLinkedList(1) a2q2
3. isStackPairwiseConsecutive(1) a2q3
4. reverseQueue(1) a2q4
5. removeUntil(1) l2q1
6. recursiveReverse(1) l2q2
7. palindrom(1) l2q3
8. balance(1) l2q4
9. reverseStack(1) t2q1
10. reverseFirstKItems(1) t2q2
11. sortStack(1) t2q3
12E Where the practice questions?
--------------------------------------------------------------------------------------------------
1. createQueueFromLinkedList()
int x=ll->size, i;
	ListNode *temp;

	//empty queue
	while(!isEmptyQueue(q)){
        dequeue(q);
	}
	//sanity check
    if (x==0) return;
	//add
	temp=ll->head;
	for (i=0;i<x;i++){
	enqueue(q,temp->item);
	temp=temp->next;
	}
	return;
--------------------------------------------------------------------------------------------------
2. createStackFromLinkedList()
int x=ll->size,i;
	ListNode *temp;
	//empty list
	while(!isEmptyStack(s)) pop(s);

	//sanity check
	if (x==0) return;
	temp=ll->head;
	for(i=0;i<x;i++){
        push(s,temp->item);
        temp=temp->next;
	}
	return;
--------------------------------------------------------------------------------------------------
3. isStackPairwiseConsecutive()
int x=s->ll.size,i,a,b;
  if (x==0) return 0;
  if (x%2==1) return 0;
  for (i=0;i<x/2;i++){
        a=pop(s);
        b=pop(s);
        if (a==b+1||a==b-1) continue;
        else return 0;
  }
  return 1;
}
void push(Stack *s, int item){
   insertNode(&(s->ll), 0, item);
}

int pop(Stack *s){
   int item;
   if(!isEmptyStack(s)){
    item = ((s->ll).head)->item;
    removeNode(&(s->ll), 0);
    return item;
   }
    return INT_MIN;
--------------------------------------------------------------------------------------------------
4. reverseQueue()
    Stack s;
    s.ll.head=NULL;
    s.ll.size=0;

    while(!isEmptyQueue(q))push(&s,dequeue(q));
    while(!isEmptyStack(&s)) enqueue(q,pop(&s));
    return;
--------------------------------------------------------------------------------------------------
5. removeUntil()
while (!isEmptyStack(s)){
        if (peek(s)!=value) {
            pop(s);
        }
        else break;

}
--------------------------------------------------------------------------------------------------
6. recursiveReverse()
if (isEmptyQueue(q)) return;
	int i=dequeue(q);
	recursiveReverse(q);
	enqueue(q,i);
	return;
	/*Stack s;
	s.ll.head=NULL;
	s.ll.size=0;
	while (!isEmptyQueue(q)){
        push(&s,dequeue(q));
	}
	while (!isEmptyStack(&s)){
        enqueue(q,pop(&s));
	}*/
--------------------------------------------------------------------------------------------------
7. palindrom()
printf("%s\n", word);
	Stack s;
	s.ll.head=NULL;
	s.ll.size=0;
	Queue q;
	q.ll.head=NULL;
	q.ll.size=0;

	while (*word){
        if (*word!=' '){
        push(&s,toupper(*word));
        enqueue(&q,toupper(*word));
        }
        word++;
	}
  //for (i=0;i<5;i++){
	while (!isEmptyQueue(&q)){
        if (dequeue(&q)!=pop(&s)){
            printf("The string is not a palindrome.\n");
            return -1;
        }
	}
	printf("The String is a palindrome.\n");
	return 0;
// Put the whole string in a stack, stripping out spaces
/*
     int i;
     Stack s; Queue q;
     s.ll.head = NULL;
     s.ll.tail = NULL;
     s.ll.size = 0;
     q.ll.head = NULL;
     q.ll.tail = NULL;
     q.ll.size = 0;

     // Put the whole string in a stack and a queue, stripping out spaces
     printf("%s\n", word);
     while (*word){
          if (*word != ' '){
               push(&s, toupper(*word));
               enqueue(&q, toupper(*word));
          }
          word++;
     }
     // divide size by 2,ignore the middle character in an odd-length string
     i = s.ll.size / 2; //i = 2 (5/2=2)

     // Pop first half of stripped string off the stack
     //Compare with the second half
     while (i > 0){
          if (pop(&s) != dequeue(&q)){
               printf("The string is not a palindrome\n");
               return -1;
          }
          i--;
     }
     printf("The string is a palindrome\n");
     return 0;*/
--------------------------------------------------------------------------------------------------
8. balance() 
Stack s;
	s.ll.head=NULL;
	s.ll.size=0;

    while (*expression){
        if (*expression=='{'||*expression=='['||*expression=='('){
                push(&s,*expression);

        }
        else if(*expression=='}'){
            if (isEmptyStack(&s)||pop(&s)!='{') return -1;
        }
        else if(*expression==']'){
            if (isEmptyStack(&s)||pop(&s)!='[') return -1;
        }
        else if(*expression==')'){
            if (isEmptyStack(&s)||pop(&s)!='(') return -1;
        }
        expression++;
    }
    if(isEmptyStack(&s)) return 0;
    else return -1;
	/*
	int a1=0,a2=0,b1=0,b2=0,c1=0,c2=0;
	while(*expression){
        if (*expression=='(') {a1+=1;}
        if (*expression==')') a2+=1;
        if (*expression=='[') b1+=1;
        if (*expression==']') b2+=1;
        if (*expression=='{') c1+=1;
        if (*expression=='}') c2+=1;
        expression++;
	}
    if (a1!=a2 || b1!=b2 || c1!=c2){
        return 1;
    }
    return 0;*/
--------------------------------------------------------------------------------------------------
9. reverseStack()
/* add your code here*/
	int a=(s->ll).size,i=0;
	Queue q;
	q.ll.head=NULL;
	q.ll.size=0;
	q.ll.tail=NULL;

	for (i=0;i<a;i++){
        enqueue(&q,pop(s));
	}
	for (i=0;i<a;i++){

        push(s,dequeue(&q));
	}

	/*
	int item;
	Queue q;

	q.ll.head = NULL;
	q.ll.size = 0;

	while (!isEmptyStack(s))
	{
		enqueue(&q, pop(s));
	}

	while (!isEmptyQueue(&q))
	{
		push(s, dequeue(&q));
	}
	*/


}
/* Answer
{

    int item;
     Queue q;
     q.ll.head = NULL;
     q.ll.size = 0;

     while (!isEmptyStack(s)){
          enqueue(&q, pop(s));
     }

     while (!isEmptyQueue(&q)){
          push(s, dequeue(&q));
     }


}*/
--------------------------------------------------------------------------------------------------
10. reverseFirstKItems()
Stack s;
    s.ll.head=NULL;
    s.ll.tail=NULL;
    s.ll.size=0;
    int i,a=(q->ll).size;
    a-=k;
    for (i=0;i<k;i++){
        push(&s,dequeue(q));
    }
    for (i=0;i<k;i++){
        enqueue(q,pop(&s));
    }
    for (i=0;i<a;i++){
        enqueue(q,dequeue(q));
    }
    /*
    Stack s;
    int i , j;

    if(k <= 0)
        return;
    if(isEmptyQueue(q) || k > q->ll.size)
        return;

    s.ll.head = NULL;
    s.ll.tail = NULL;
    s.ll.size = 0;



    for(i=0; i < k; i++){
        push(&s,dequeue(q));
    }

    while(!isEmptyStack(&s)){
        enqueue(q,pop(&s));
    }
    j = q->ll.size;

    for(i=0; i< j-k;i++){
        enqueue(q,dequeue(q));
    }
    */
--------------------------------------------------------------------------------------------------
11. sortStack()
Stack ss;
    ss.ll.head=NULL;
    ss.ll.size=0;

    /*
    int i,j,o,m=0,t=(s->ll).size,c,k;
    k=t;
    for (i=0;i<k;i++){
    for (j=0;j<t;j++){
        c=pop(s);
        if (c>m){
            if(m!=0){push(&ss,m);}
            m=c;
    }
        else push(&ss,c);
    }
    push(s,m);
    t--;
    for (o=0;o<t;o++) push(s,pop(&ss));
    m=0;
}*/
    //model answer
    int temp;
    Stack ts;
    ts.ll.head = NULL;
    ts.ll.tail = NULL;
    ts.ll.size = 0;

    while(!isEmptyStack(s)){
        push(&ts,pop(s));
    }

    while(!isEmptyStack(&ts)){
        temp = pop(&ts);

       while(!isEmptyStack(s) && peek(s) < temp){
           push(&ts,pop(s));
       }
        push(s,temp);
    }
