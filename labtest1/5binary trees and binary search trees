1. identical()
2. maxHeight()
3. maxDepth()
4. countOneChildNodes()
5. sumOfOddNodes()
6. mirroeTree()
7. printSmallestValues()
8. smallestValue()
9. hasGreatGrandchild()
10. levelOrderTraversal()
11. inOrderTraversal() //using stack and iterative
12. preOrderIterative()
13. postOrderIterativeS1() //using stack and iterative
14. postOrderIterativeS2() //using 2 stacks and while loop
15. printBSTInOrder()
16. isBST()
--------------------------------------------------------------------------------------------------
1. identical()
	if (tree1==NULL && tree2==NULL) return 1;
   if ((tree1==NULL)!=(tree2==NULL)) return 0;

   if (tree1->item!=tree2->item) return 0;
   /*
   if (!identical(tree1->left,tree2->left)){
        return 0;
   }

    if (!identical(tree1->right,tree2->right)){
        return 0;
    }

   return 1;*/
   return identical(tree1->left, tree2->left) && identical(tree1->right, tree2->right);
--------------------------------------------------------------------------------------------------
2. maxHeight()
--------------------------------------------------------------------------------------------------
3. maxDepth()
int c=-1,l,r;
    if (node==NULL) return -1;
    l=maxDepth(node->left);
    if (c<l) c=l;
    r=maxDepth(node->right);
    if (c<r) c=r;
    return c+1;
    
    OR
    
    
    if(node == NULL){
        return -1;
    }
    else{
        int ldepth = maxDepth(node->left);
        int rdepth = maxDepth(node->right);

        if(ldepth > rdepth) return ldepth+1;
        else{
            return rdepth+1;
        }
    }
------------------------------------------------------------------------------------
4. countOneChildNodes()
--------------------------------------------------------------------------------------------------
5. sumOfOddNodes()
--------------------------------------------------------------------------------------------------
6. mirroeTree()
--------------------------------------------------------------------------------------------------
7. printSmallestValues()
--------------------------------------------------------------------------------------------------
8. smallestValue()
--------------------------------------------------------------------------------------------------
9. hasGreatGrandchild()
--------------------------------------------------------------------------------------------------
10. levelOrderTraversal()
Queue q;
    q.head=NULL;
    q.tail=NULL;
    BSTNode *temp;
    temp=root;

    if (temp!=NULL){
        enqueue(&q.head,&q.tail,root);

        while (!isEmpty(q.head)){
            temp=dequeue(&q.head,&q.tail);
            printf("%d ",temp->item);
            if (temp->left!=NULL) enqueue(&q.head,&q.tail,temp->left);
            if (temp->right!=NULL) enqueue(&q.head,&q.tail,temp->right);
        }

    }
    ------------------------------------------------------------------------------------------------
11. inOrderTraversal()
	Stack s;
	 s.top=NULL;
	 BSTNode *temp;
	 temp=root;

    if (temp==NULL) return;
    push(&s,temp);
    inOrderTraversal(temp->left);
    while (!isEmpty(&s)){
        temp=pop(&s);
        printf("%d ",temp->item);
        if(temp->right!=NULL){
            inOrderTraversal(temp->right);

        }
    }
--------------------------------------------------------------------------------------------------
12. preOrderIterative()
Stack s;
	 s.top=NULL;
	 BSTNode *temp;
	 temp = root;

	 if(temp!=NULL){
        push(&s,temp);
        while (!isEmpty(&s)){
            temp=pop(&s);
            printf("%d ",temp->item);
            if (temp->right!=NULL) push(&s,temp->right);
            if (temp->left!=NULL) push(&s,temp->left);
        }
	 }
	 return;
--------------------------------------------------------------------------------------------------
13. postOrderIterativeS1()
Stack s;
    s.top=NULL;
    BSTNode *temp,*t;
    temp=root;

    while (temp!=NULL){
        if (temp->right!=NULL) push(&s,temp->right);
        push(&s,temp);
        temp=temp->left;
    }
    while(!isEmpty(&s)){

        temp = pop(&s);

        if ((temp->right)!=NULL && peek(&s)==(temp->right)){
        pop(&s);
        push(&s,temp);
        postOrderIterativeS1(temp->right);
        }
        else {
        printf("%d ",temp->item);
        temp=NULL;
        }
    return;
--------------------------------------------------------------------------------------------------
14. postOrderIterativeS2()
Stack s1,s2;
	 s1.top=NULL;
	 s2.top=NULL;
	 BSTNode *temp;

	 push(&s1,root);

	 while(!isEmpty(&s1)){
        temp=pop(&s1);
        push(&s2,temp);
        if (temp->left!=NULL) push(&s1,temp->left);
        if(temp->right!=NULL) push(&s1,temp->right);

 	 }
 	 while (!isEmpty(&s2)) {
            temp=pop(&s2);
            printf("%d ",temp->item);
     }
     return;
--------------------------------------------------------------------------------------------------
15. printBSTInOrder()
--------------------------------------------------------------------------------------------------
16. isBST()
